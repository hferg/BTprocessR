% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plotShifts.R
\name{plotShifts}
\alias{plotShifts}
\title{plotShifts}
\usage{
plotShifts(PP, plot.options = list(), ...)
}
\arguments{
\item{PP}{The output of the rjpp function.}

\item{plot.options}{A list of control options. See details.}

\item{...}{Additional arguments passed to plotPhylo}
}
\description{
Plots the locations of the origins of scalars from the postprocessor output
of bayestraits.
}
\details{
The default behaviour of plotShifts depends on the transformations
present in the rjpp output. If variable rates, then 3 trees will be plotted:
the first has branches coloured according the log of the mean rate, the 
second shows all node scalars present more than once in the posterior, 
coloured according to the mean log rate and the third shows the same for 
branch scalars. If delta, kappa or lambda are present then a single tree is 
plotted showing all nodes that receive a scalar, coloured according to mean 
magnitude. If multiple transformations are present then the user will be
prompted to select one. 
The plot.options list provides a high degree of control over what
is plotted, allowing the default behaviour to be customised. The options, and
values that they can take, are as follows.

\itemize{
\item{threshold:}{ [0-1] The threshold of presence in the posterior over which 
a node and/or branch scalar is plotted. Also the threshold referenced by 
coloured.edges and scaled.edges.}
\item{transformation:}{ [rate, delta, lambda, kappa] The transformation to 
plot.}
\item{edge.colour:}{ [none, mean, median, mode, sd, scale_pc] The metric to
colour edges by. If none branches default to the na.colour option. Mean,
median, mode and sd correspond to the appropriate branch lengths from the 
posterior of trees and scale_pc colours edges according to the percentage of
time they are scaled in the posterior.}
\item{edge.transparency:}{ [none, scale_pc, sd] The measure to make edges 
proportionally transparent by. None results in uniform solid branches, 
scale_pc gives edges that are scaled less frequently in the posterior higher
transparency, and sd gives branches that have higher SD of estimated branch
lengths more solid colours.}
\item{coloured.edges:}{ [all, threshold] The edges to colour. If "all" then
all edges are coloured according to edge.colour, otherwise if "threshold"
then only edges that are scaled over the specified threshold are coloured.
Uncoloured edges default to na.colour}
\item{edge.palette:}{ [viridis, magma, inferno, plasma, viridis, 
c("<colour1>", "<colour2>")] The colour palette for edges. If not using a 
named palette then a vector of at least two colours must be specified - the 
first will be the low end of the palette and the last the top end. Any other
colours in the vector will be included in the gradient.}
\item{edge.scale:}{ [none, mean, median, mode]}
\item{scaled.edges:}{ [all, threshold]}
\item{node.colour:}{ []}
\item{node.scale:}{ []}
\item{node.transparency:}{ []}
\item{node.palette:}{ [viridis, magma, inferno, plasma, viridis, 
c("<colour1>", "<colour2>")] The colour palette for node symbols. If not 
using a named palette then a vector of at least two colours must be 
specified - the first will be the low end of the palette and the last the top 
end. Any other colours in the vector will be included in the gradient.}
\item{node.fill:}{ []}
\item{node.border:}{ []}
\item{node.shape:}{ ["circle"] The shape for the node labels - "circle",
"square", "diamond", "uptriangle", "downtriangle".}
\item{node.cex:}{ [0-??] The scaling factor for node symbols. This is the 
scaling factor that the symbols start at before any subsequent scaling (i.e.
if a node symbol receives no scaling, this is what it's scaling factor will
be.)}
\item{branch.colour:}{ []}
\item{branch.transparency:}{ []}
\item{branch.palette:}{ [viridis, magma, inferno, plasma, viridis, 
c("<colour1>", "<colour2>")] The colour palette for branch symbols. If not 
using a named palette then a vector of at least two colours must be 
specified - the first will be the low end of the palette and the last the top 
end. Any other colours in the vector will be included in the gradient.}
\item{branch.fill:}{ []}
\item{branch.border:}{ []}
\item{branch.scale:}{ []}
\item{branch.shape:}{ ["circle"] The shape for the branch labels - "circle",
"square", "diamond", "uptriangle", "downtriangle".}
\item{branch.cex:}{ [0-??] The scaling factor for branch symbols. This is the 
scaling factor that the symbols start at before any subsequent scaling (i.e.
if a branch symbol receives no scaling, this is what it's scaling factor will
be.}
\item{na.colour:}{ []}
\item{layout:}{ [c("e", "n", "b")] This controls the layout of the plots. The
option takes the form of a vector of letters - "e", "n" and/or "b". Each 
element of the vector is a new panel in the plot, and the composition of
letters in the element determins whether coloured edges - "e" - node labels -
"n" - and/or branch labels - "b" - are plotted. e.g. c("e", "n", "b") gives a
three panel plot - one panel with coloured edges, one with node labels and 
one with branch labels. c("en", "b") produces two plots - one with coloured
edges and node labels and one with branch labels. c("enb") produces a single
plot with edges, node labels and branch labels.}
\item{legend.pos:}{ [auto, c(xl, yb, xr, yt)] The legend position on the 
plot. If "auto" then the legend position will be in the bottom right at 
"best guess" coordinates. Otherwise a vector of coordinates for bottom left
and top right corner of the legend.}
\item{legend:}{ []}
}
}
